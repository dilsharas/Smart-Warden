"""
Vulnerability-specific feature detection for smart contracts.
"""

import re
import ast
from typing import Dict, List, Optional, Tuple, Set
import logging

logger = logging.getLogger(__name__)


class VulnerabilitySpecificDetector:
    """
    Detects vulnerability-specific patterns in Solidity smart contracts.
    
    Focuses on detailed analysis of:
    - Reentrancy vulnerabilities
    - Access control issues
    - Arithmetic overflow/underflow
    - Unchecked external calls
    - Denial of service patterns
    - Bad randomness usage
    """
    
    def __init__(self):
        """Initialize the vulnerability detector."""
        self.reentrancy_patterns = self._init_reentrancy_patterns()
        self.access_control_patterns = self._init_access_control_patterns()
        self.arithmetic_patterns = self._init_arithmetic_patterns()
        self.external_call_patterns = self._init_external_call_patterns()
        self.dos_patterns = self._init_dos_patterns()
        self.randomness_patterns = self._init_randomness_patterns()
    
    def detect_reentrancy_features(self, code: str) -> Dict[str, float]:
        """
        Detect reentrancy vulnerability patterns.
        
        Args:
            code: Solidity contract code
            
        Returns:
            Dictionary of reentrancy-specific features
        """
        features = {}
        
        # Basic external call detection
        features['external_calls_total'] = self._count_external_calls(code)
        features['call_value_usage'] = float('.call{value:' in code or '.call.value(' in code)
        features['send_usage'] = float('.send(' in code)
        features['transfer_usage'] = float('.transfer(' in code)
        
        # State changes after external calls (classic reentrancy pattern)
        features['state_change_after_call'] = self._detect_state_change_after_call(code)
        features['balance_update_after_call'] = self._detect_balance_update_after_call(code)
        
        # Reentrancy guards
        features['has_reentrancy_guard'] = self._detect_reentrancy_guard(code)
        features['has_mutex_pattern'] = self._detect_mutex_pattern(code)
        features['checks_effects_interactions'] = self._check_cei_pattern(code)
        
        # Function-level analysis
        features['payable_functions_with_calls'] = self._count_payable_functions_with_calls(code)
        features['fallback_with_external_calls'] = self._detect_fallback_external_calls(code)
        
        # Advanced patterns
        features['nested_external_calls'] = self._detect_nested_external_calls(code)
        features['external_calls_in_loops'] = self._detect_calls_in_loops(code)
        
        return features
    
    def detect_access_control_features(self, code: str) -> Dict[str, float]:
        """
        Detect access control vulnerability patterns.
        
        Args:
            code: Solidity contract code
            
        Returns:
            Dictionary of access control features
        """
        features = {}
        
        # Modifier usage
        features['modifier_definitions'] = len(re.findall(r'modifier\s+\w+', code))
        features['onlyOwner_modifier'] = float('onlyOwner' in code)
        features['custom_access_modifiers'] = self._count_custom_access_modifiers(code)
        
        # Owner patterns
        features['owner_variable_exists'] = float(bool(re.search(r'\bowner\b', code)))
        features['owner_initialization'] = self._detect_owner_initialization(code)
        features['owner_transfer_function'] = self._detect_owner_transfer(code)
        
        # Permission checks
        features['msg_sender_checks'] = code.count('msg.sender')
        features['require_statements'] = code.count('require(')
        features['assert_statements'] = code.count('assert(')
        
        # Function visibility
        functions = self._extract_function_signatures(code)
        features['public_functions'] = len([f for f in functions if 'public' in f])
        features['external_functions'] = len([f for f in functions if 'external' in f])
        features['private_functions'] = len([f for f in functions if 'private' in f])
        features['internal_functions'] = len([f for f in functions if 'internal' in f])
        
        # Dangerous public functions
        features['public_payable_functions'] = len([f for f in functions if 'public' in f and 'payable' in f])
        features['unprotected_functions'] = self._count_unprotected_functions(code)
        
        # Constructor security
        features['constructor_exists'] = float('constructor(' in code)
        features['constructor_access_control'] = self._check_constructor_access_control(code)
        
        return features
    
    def detect_arithmetic_features(self, code: str) -> Dict[str, float]:
        """
        Detect arithmetic overflow/underflow patterns.
        
        Args:
            code: Solidity contract code
            
        Returns:
            Dictionary of arithmetic vulnerability features
        """
        features = {}
        
        # Solidity version analysis
        version = self._extract_solidity_version(code)
        features['solidity_version_major'] = float(int(version.split('.')[0]) if version else 0)
        features['solidity_version_minor'] = float(int(version.split('.')[1]) if '.' in version else 0)
        features['has_overflow_protection'] = float(version >= '0.8.0' if version else False)
        
        # SafeMath usage
        features['uses_safemath'] = float('SafeMath' in code)
        features['safemath_operations'] = len(re.findall(r'SafeMath\.\w+', code))
        
        # Arithmetic operations
        features['addition_operations'] = len(re.findall(r'\w+\s*\+\s*\w+', code))
        features['subtraction_operations'] = len(re.findall(r'\w+\s*-\s*\w+', code))
        features['multiplication_operations'] = len(re.findall(r'\w+\s*\*\s*\w+', code))
        features['division_operations'] = len(re.findall(r'\w+\s*/\s*\w+', code))
        
        # Compound assignments (higher risk)
        features['compound_additions'] = code.count('+=')
        features['compound_subtractions'] = code.count('-=')
        features['compound_multiplications'] = code.count('*=')
        features['compound_divisions'] = code.count('/=')
        
        # Unchecked arithmetic blocks
        features['unchecked_blocks'] = code.count('unchecked {')
        
        # High-risk patterns
        features['arithmetic_in_loops'] = self._detect_arithmetic_in_loops(code)
        features['user_controlled_arithmetic'] = self._detect_user_controlled_arithmetic(code)
        
        return features
    
    def detect_external_call_features(self, code: str) -> Dict[str, float]:
        """
        Detect unchecked external call patterns.
        
        Args:
            code: Solidity contract code
            
        Returns:
            Dictionary of external call features
        """
        features = {}
        
        # Low-level calls
        features['call_usage'] = code.count('.call(')
        features['delegatecall_usage'] = code.count('.delegatecall(')
        features['staticcall_usage'] = code.count('.staticcall(')
        features['callcode_usage'] = code.count('.callcode(')
        
        # Return value checking
        features['checked_call_returns'] = self._count_checked_call_returns(code)
        features['unchecked_call_returns'] = self._count_unchecked_call_returns(code)
        
        # Gas handling
        features['calls_with_gas_limit'] = self._count_calls_with_gas_limit(code)
        features['calls_without_gas_limit'] = self._count_calls_without_gas_limit(code)
        
        # Error handling
        features['try_catch_blocks'] = code.count('try ')
        features['require_after_call'] = self._count_require_after_call(code)
        
        # Interface calls
        features['interface_calls'] = self._count_interface_calls(code)
        features['external_contract_calls'] = self._count_external_contract_calls(code)
        
        return features
    
    def detect_dos_features(self, code: str) -> Dict[str, float]:
        """
        Detect denial of service patterns.
        
        Args:
            code: Solidity contract code
            
        Returns:
            Dictionary of DoS vulnerability features
        """
        features = {}
        
        # Loop patterns
        features['unbounded_loops'] = self._detect_unbounded_loops(code)
        features['loops_over_arrays'] = self._detect_loops_over_arrays(code)
        features['nested_loops'] = self._detect_nested_loops(code)
        
        # Gas consumption patterns
        features['expensive_operations_in_loops'] = self._detect_expensive_ops_in_loops(code)
        features['storage_writes_in_loops'] = self._detect_storage_writes_in_loops(code)
        features['external_calls_in_loops'] = self._detect_external_calls_in_loops(code)
        
        # Array operations
        features['dynamic_array_operations'] = self._count_dynamic_array_ops(code)
        features['array_push_operations'] = code.count('.push(')
        features['array_pop_operations'] = code.count('.pop()')
        
        # Block gas limit issues
        features['potential_block_gas_limit'] = self._detect_block_gas_limit_issues(code)
        
        return features
    
    def detect_randomness_features(self, code: str) -> Dict[str, float]:
        """
        Detect bad randomness patterns.
        
        Args:
            code: Solidity contract code
            
        Returns:
            Dictionary of randomness vulnerability features
        """
        features = {}
        
        # Block properties used for randomness
        features['uses_block_timestamp'] = float('block.timestamp' in code or 'now' in code)
        features['uses_block_number'] = float('block.number' in code)
        features['uses_block_difficulty'] = float('block.difficulty' in code)
        features['uses_blockhash'] = float('blockhash(' in code)
        
        # Hash functions for randomness
        features['keccak256_for_random'] = self._detect_keccak256_randomness(code)
        features['sha256_for_random'] = self._detect_sha256_randomness(code)
        
        # Predictable patterns
        features['modulo_randomness'] = self._detect_modulo_randomness(code)
        features['address_randomness'] = self._detect_address_randomness(code)
        
        # Proper randomness sources
        features['uses_chainlink_vrf'] = float('VRFConsumer' in code or 'requestRandomness' in code)
        features['uses_commit_reveal'] = self._detect_commit_reveal_scheme(code)
        
        return features
    
    # Helper methods for reentrancy detection
    def _count_external_calls(self, code: str) -> int:
        """Count all external calls in the contract."""
        patterns = [r'\.call\(', r'\.send\(', r'\.transfer\(', r'\.delegatecall\(']
        return sum(len(re.findall(pattern, code)) for pattern in patterns)
    
    def _detect_state_change_after_call(self, code: str) -> float:
        """Detect state changes after external calls."""
        lines = code.split('\n')
        violations = 0
        
        for i in range(len(lines) - 1):
            line = lines[i].strip()
            # Check for external call
            if any(call in line for call in ['.call(', '.send(', '.transfer(']):
                # Check next few lines for state changes
                for j in range(i + 1, min(i + 4, len(lines))):
                    next_line = lines[j].strip()
                    if ('=' in next_line and '==' not in next_line and 
                        '!=' not in next_line and '>=' not in next_line and '<=' not in next_line):
                        violations += 1
                        break
        
        return float(violations)
    
    def _detect_balance_update_after_call(self, code: str) -> float:
        """Detect balance updates after external calls."""
        lines = code.split('\n')
        violations = 0
        
        for i in range(len(lines) - 1):
            line = lines[i].strip()
            if any(call in line for call in ['.call(', '.send(', '.transfer(']):
                for j in range(i + 1, min(i + 4, len(lines))):
                    next_line = lines[j].strip()
                    if 'balance' in next_line and ('=' in next_line or '+=' in next_line or '-=' in next_line):
                        violations += 1
                        break
        
        return float(violations)
    
    def _detect_reentrancy_guard(self, code: str) -> float:
        """Detect reentrancy guard patterns."""
        guard_patterns = [
            'nonReentrant',
            'reentrancyGuard',
            'mutex',
            'locked'
        ]
        return float(any(pattern in code for pattern in guard_patterns))
    
    def _detect_mutex_pattern(self, code: str) -> float:
        """Detect mutex/lock patterns."""
        return float(bool(re.search(r'(mutex|lock|locked)\s*=\s*(true|false)', code)))
    
    def _check_cei_pattern(self, code: str) -> float:
        """Check for Checks-Effects-Interactions pattern."""
        functions = self._extract_function_bodies(code)
        cei_compliant = 0
        
        for func_body in functions:
            lines = func_body.split('\n')
            has_check = False
            has_effect = False
            has_interaction = False
            
            for line in lines:
                line = line.strip()
                if 'require(' in line or 'assert(' in line:
                    has_check = True
                elif ('=' in line and not any(op in line for op in ['==', '!=', '>=', '<=']) and
                      not any(call in line for call in ['.call(', '.send(', '.transfer('])):
                    has_effect = True
                elif any(call in line for call in ['.call(', '.send(', '.transfer(']):
                    has_interaction = True
            
            if has_check and has_effect and has_interaction:
                cei_compliant += 1
        
        return float(cei_compliant)
    
    # Helper methods for access control detection
    def _count_custom_access_modifiers(self, code: str) -> int:
        """Count custom access control modifiers."""
        modifiers = re.findall(r'modifier\s+(\w+)', code)
        access_keywords = ['only', 'require', 'auth', 'permission', 'role']
        return len([m for m in modifiers if any(keyword in m.lower() for keyword in access_keywords)])
    
    def _detect_owner_initialization(self, code: str) -> float:
        """Detect proper owner initialization."""
        constructor_match = re.search(r'constructor\s*\([^)]*\)\s*[^{]*\{([^}]+)\}', code, re.DOTALL)
        if constructor_match:
            constructor_body = constructor_match.group(1)
            return float('owner' in constructor_body and 'msg.sender' in constructor_body)
        return 0.0
    
    def _detect_owner_transfer(self, code: str) -> float:
        """Detect owner transfer functionality."""
        transfer_patterns = [
            r'function\s+transferOwnership',
            r'function\s+changeOwner',
            r'owner\s*=\s*\w+'
        ]
        return float(any(re.search(pattern, code) for pattern in transfer_patterns))
    
    def _count_unprotected_functions(self, code: str) -> int:
        """Count functions without access control."""
        functions = self._extract_function_signatures(code)
        unprotected = 0
        
        for func in functions:
            if ('public' in func or 'external' in func) and 'view' not in func and 'pure' not in func:
                # Check if function has access control
                func_name = re.search(r'function\s+(\w+)', func)
                if func_name:
                    name = func_name.group(1)
                    func_body = self._get_function_body(code, name)
                    if func_body and not any(check in func_body for check in ['require(', 'onlyOwner', 'modifier']):
                        unprotected += 1
        
        return unprotected
    
    # Helper methods for arithmetic detection
    def _extract_solidity_version(self, code: str) -> str:
        """Extract Solidity version from pragma."""
        match = re.search(r'pragma\s+solidity\s+[\^>=<]*(\d+\.\d+\.\d+)', code)
        if match:
            return match.group(1)
        match = re.search(r'pragma\s+solidity\s+[\^>=<]*(\d+\.\d+)', code)
        if match:
            return match.group(1) + '.0'
        return ''
    
    def _detect_arithmetic_in_loops(self, code: str) -> float:
        """Detect arithmetic operations in loops."""
        loop_bodies = self._extract_loop_bodies(code)
        arithmetic_in_loops = 0
        
        for body in loop_bodies:
            if any(op in body for op in ['+', '-', '*', '/', '+=', '-=', '*=', '/=']):
                arithmetic_in_loops += 1
        
        return float(arithmetic_in_loops)
    
    def _detect_user_controlled_arithmetic(self, code: str) -> float:
        """Detect arithmetic with user-controlled inputs."""
        user_inputs = ['msg.value', 'msg.data', '_amount', '_value', 'amount', 'value']
        arithmetic_ops = re.findall(r'(\w+\s*[+\-*/]\s*\w+)', code)
        
        risky_ops = 0
        for op in arithmetic_ops:
            if any(inp in op for inp in user_inputs):
                risky_ops += 1
        
        return float(risky_ops)
    
    # Additional helper methods would continue here...
    # For brevity, I'll include key methods and indicate where others would go
    
    def _extract_function_signatures(self, code: str) -> List[str]:
        """Extract function signatures from code."""
        return re.findall(r'function\s+\w+\s*\([^)]*\)\s*[^{]*', code)
    
    def _extract_function_bodies(self, code: str) -> List[str]:
        """Extract function bodies from code."""
        functions = []
        pattern = r'function\s+\w+\s*\([^)]*\)\s*[^{]*\{([^}]+)\}'
        matches = re.findall(pattern, code, re.DOTALL)
        return matches
    
    def _get_function_body(self, code: str, function_name: str) -> str:
        """Get the body of a specific function."""
        pattern = rf'function\s+{function_name}\s*\([^)]*\)\s*[^{{]*\{{([^}}]+)\}}'
        match = re.search(pattern, code, re.DOTALL)
        return match.group(1) if match else ''
    
    def _extract_loop_bodies(self, code: str) -> List[str]:
        """Extract loop bodies from code."""
        loop_patterns = [
            r'for\s*\([^)]*\)\s*\{([^}]+)\}',
            r'while\s*\([^)]*\)\s*\{([^}]+)\}'
        ]
        bodies = []
        for pattern in loop_patterns:
            bodies.extend(re.findall(pattern, code, re.DOTALL))
        return bodies
    
    # Initialize pattern dictionaries
    def _init_reentrancy_patterns(self) -> Dict:
        """Initialize reentrancy detection patterns."""
        return {
            'external_calls': ['.call(', '.send(', '.transfer(', '.delegatecall('],
            'state_changes': ['=', '+=', '-=', '*=', '/='],
            'guards': ['nonReentrant', 'reentrancyGuard', 'mutex']
        }
    
    def _init_access_control_patterns(self) -> Dict:
        """Initialize access control patterns."""
        return {
            'modifiers': ['onlyOwner', 'onlyAdmin', 'requireAuth'],
            'checks': ['require(', 'assert(', 'msg.sender'],
            'roles': ['owner', 'admin', 'authorized']
        }
    
    def _init_arithmetic_patterns(self) -> Dict:
        """Initialize arithmetic patterns."""
        return {
            'operations': ['+', '-', '*', '/', '**'],
            'assignments': ['+=', '-=', '*=', '/='],
            'safe_libs': ['SafeMath', 'SafeERC20']
        }
    
    def _init_external_call_patterns(self) -> Dict:
        """Initialize external call patterns."""
        return {
            'low_level': ['.call(', '.delegatecall(', '.staticcall('],
            'high_level': ['.send(', '.transfer('],
            'checks': ['require(', 'if (', 'assert(']
        }
    
    def _init_dos_patterns(self) -> Dict:
        """Initialize DoS patterns."""
        return {
            'loops': ['for (', 'while ('],
            'arrays': ['.push(', '.pop()', '.length'],
            'expensive': ['sstore', 'create', 'call']
        }
    
    def _init_randomness_patterns(self) -> Dict:
        """Initialize randomness patterns."""
        return {
            'block_props': ['block.timestamp', 'block.number', 'block.difficulty'],
            'hash_funcs': ['keccak256', 'sha256', 'ripemd160'],
            'predictable': ['now', 'blockhash']
        }
    
    # Placeholder methods for remaining detections
    def _count_payable_functions_with_calls(self, code: str) -> float:
        """Count payable functions that make external calls."""
        # Implementation would analyze payable functions for external calls
        return 0.0
    
    def _detect_fallback_external_calls(self, code: str) -> float:
        """Detect external calls in fallback functions."""
        # Implementation would check fallback/receive functions
        return 0.0
    
    def _detect_nested_external_calls(self, code: str) -> float:
        """Detect nested external calls."""
        # Implementation would find calls within calls
        return 0.0
    
    def _detect_calls_in_loops(self, code: str) -> float:
        """Detect external calls inside loops."""
        loop_bodies = self._extract_loop_bodies(code)
        calls_in_loops = 0
        
        for body in loop_bodies:
            if any(call in body for call in ['.call(', '.send(', '.transfer(']):
                calls_in_loops += 1
        
        return float(calls_in_loops)
    
    # Additional placeholder methods would be implemented here...
    # Each would provide specific detection logic for their respective patterns


def main():
    """Example usage of VulnerabilitySpecificDetector."""
    sample_contract = """
    pragma solidity ^0.7.0;
    
    contract VulnerableContract {
        mapping(address => uint256) public balances;
        address public owner;
        
        constructor() {
            owner = msg.sender;
        }
        
        function withdraw(uint256 amount) public {
            require(balances[msg.sender] >= amount);
            
            // Reentrancy vulnerability
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success);
            
            balances[msg.sender] -= amount;  // State change after call
        }
        
        function emergencyWithdraw() public {
            // Missing access control
            selfdestruct(payable(msg.sender));
        }
        
        function badRandom() public view returns (uint256) {
            // Bad randomness
            return uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 100;
        }
    }
    """
    
    detector = VulnerabilitySpecificDetector()
    
    print("Reentrancy Features:")
    reentrancy_features = detector.detect_reentrancy_features(sample_contract)
    for feature, value in reentrancy_features.items():
        print(f"  {feature}: {value}")
    
    print("\nAccess Control Features:")
    access_features = detector.detect_access_control_features(sample_contract)
    for feature, value in access_features.items():
        print(f"  {feature}: {value}")
    
    print("\nArithmetic Features:")
    arithmetic_features = detector.detect_arithmetic_features(sample_contract)
    for feature, value in arithmetic_features.items():
        print(f"  {feature}: {value}")
    
    print("\nRandomness Features:")
    randomness_features = detector.detect_randomness_features(sample_contract)
    for feature, value in randomness_features.items():
        print(f"  {feature}: {value}")


if __name__ == "__main__":
    main()