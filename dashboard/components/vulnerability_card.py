"""
Vulnerability card component for displaying security findings.
"""

import streamlit as st
from typing import Dict, List, Any
import plotly.express as px
import plotly.graph_objects as go


def show_vulnerability_card(vulnerability: Dict[str, Any]) -> None:
    """
    Display a single vulnerability finding as a card.
    
    Args:
        vulnerability: Dictionary containing vulnerability information
    """
    # Determine severity color
    severity = vulnerability.get('severity', 'Unknown').lower()
    severity_colors = {
        'critical': '#ff4444',
        'high': '#ff8800',
        'medium': '#ffaa00',
        'low': '#ffdd00',
        'info': '#4488ff',
        'unknown': '#888888'
    }
    
    color = severity_colors.get(severity, '#888888')
    
    # Create card HTML
    card_html = f"""
    <div style="
        border-left: 5px solid {color};
        background-color: #f8f9fa;
        padding: 1rem;
        margin: 0.5rem 0;
        border-radius: 0 8px 8px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    ">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <h4 style="margin: 0; color: #333;">
                {vulnerability.get('vulnerability_type', 'Unknown').replace('_', ' ').title()}
            </h4>
            <span style="
                background-color: {color};
                color: white;
                padding: 0.2rem 0.5rem;
                border-radius: 12px;
                font-size: 0.8rem;
                font-weight: bold;
            ">
                {vulnerability.get('severity', 'Unknown').upper()}
            </span>
        </div>
        
        <p style="margin: 0.5rem 0; color: #666;">
            <strong>Line {vulnerability.get('line_number', 'Unknown')}:</strong> 
            {vulnerability.get('description', 'No description available')}
        </p>
        
        <div style="margin-top: 0.5rem;">
            <small style="color: #888;">
                Confidence: {vulnerability.get('confidence', 'Unknown')} | 
                Function: {vulnerability.get('function_name', 'Unknown')}
            </small>
        </div>
    </div>
    """
    
    st.markdown(card_html, unsafe_allow_html=True)
    
    # Show additional details in expander
    with st.expander("View Details"):
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Vulnerability Details:**")
            st.write(f"â€¢ Type: {vulnerability.get('vulnerability_type', 'Unknown')}")
            st.write(f"â€¢ Severity: {vulnerability.get('severity', 'Unknown')}")
            st.write(f"â€¢ Confidence: {vulnerability.get('confidence', 'Unknown')}")
            st.write(f"â€¢ Line: {vulnerability.get('line_number', 'Unknown')}")
            st.write(f"â€¢ Function: {vulnerability.get('function_name', 'Unknown')}")
        
        with col2:
            if 'recommendation' in vulnerability:
                st.write("**Recommendation:**")
                st.info(vulnerability['recommendation'])
        
        if 'code_snippet' in vulnerability and vulnerability['code_snippet']:
            st.write("**Code Snippet:**")
            st.code(vulnerability['code_snippet'], language='solidity')


def show_vulnerability_summary(vulnerabilities: List[Dict[str, Any]]) -> None:
    """
    Display a summary of all vulnerabilities found.
    
    Args:
        vulnerabilities: List of vulnerability dictionaries
    """
    if not vulnerabilities:
        st.success("ğŸ‰ No vulnerabilities detected!")
        return
    
    # Count by severity
    severity_counts = {}
    for vuln in vulnerabilities:
        severity = vuln.get('severity', 'Unknown')
        severity_counts[severity] = severity_counts.get(severity, 0) + 1
    
    # Display summary metrics
    st.markdown("### ğŸ” Vulnerability Summary")
    
    cols = st.columns(len(severity_counts) + 1)
    
    with cols[0]:
        st.metric("Total Found", len(vulnerabilities))
    
    severity_order = ['Critical', 'High', 'Medium', 'Low', 'Info']
    col_idx = 1
    
    for severity in severity_order:
        if severity in severity_counts:
            with cols[col_idx]:
                st.metric(severity, severity_counts[severity])
                col_idx += 1
    
    # Create severity distribution chart
    if len(severity_counts) > 1:
        fig = px.pie(
            values=list(severity_counts.values()),
            names=list(severity_counts.keys()),
            title="Vulnerability Distribution by Severity",
            color_discrete_map={
                'Critical': '#ff4444',
                'High': '#ff8800',
                'Medium': '#ffaa00',
                'Low': '#ffdd00',
                'Info': '#4488ff'
            }
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)


def show_vulnerability_timeline(vulnerabilities: List[Dict[str, Any]]) -> None:
    """
    Display vulnerabilities by line number as a timeline.
    
    Args:
        vulnerabilities: List of vulnerability dictionaries
    """
    if not vulnerabilities:
        return
    
    st.markdown("### ğŸ“ Vulnerability Locations")
    
    # Sort by line number
    sorted_vulns = sorted(vulnerabilities, key=lambda x: x.get('line_number', 0))
    
    # Create timeline visualization
    line_numbers = [v.get('line_number', 0) for v in sorted_vulns]
    severities = [v.get('severity', 'Unknown') for v in sorted_vulns]
    types = [v.get('vulnerability_type', 'Unknown') for v in sorted_vulns]
    
    fig = go.Figure()
    
    severity_colors = {
        'Critical': '#ff4444',
        'High': '#ff8800',
        'Medium': '#ffaa00',
        'Low': '#ffdd00',
        'Info': '#4488ff',
        'Unknown': '#888888'
    }
    
    for i, (line, severity, vuln_type) in enumerate(zip(line_numbers, severities, types)):
        fig.add_trace(go.Scatter(
            x=[line],
            y=[i],
            mode='markers',
            marker=dict(
                size=15,
                color=severity_colors.get(severity, '#888888'),
                line=dict(width=2, color='white')
            ),
            text=f"Line {line}: {vuln_type}",
            hovertemplate=f"<b>Line {line}</b><br>{vuln_type}<br>Severity: {severity}<extra></extra>",
            showlegend=False
        ))
    
    fig.update_layout(
        title="Vulnerabilities by Line Number",
        xaxis_title="Line Number",
        yaxis_title="Vulnerability Index",
        height=400,
        showlegend=False
    )
    
    st.plotly_chart(fig, use_container_width=True)


def show_vulnerability_heatmap(vulnerabilities: List[Dict[str, Any]], total_lines: int) -> None:
    """
    Display a heatmap showing vulnerability density across the contract.
    
    Args:
        vulnerabilities: List of vulnerability dictionaries
        total_lines: Total number of lines in the contract
    """
    if not vulnerabilities or total_lines == 0:
        return
    
    st.markdown("### ğŸ”¥ Vulnerability Heatmap")
    
    # Create line-based vulnerability density
    line_counts = {}
    for vuln in vulnerabilities:
        line = vuln.get('line_number', 0)
        if line > 0:
            line_counts[line] = line_counts.get(line, 0) + 1
    
    # Group lines into buckets for visualization
    bucket_size = max(1, total_lines // 50)  # 50 buckets max
    buckets = {}
    
    for line, count in line_counts.items():
        bucket = (line - 1) // bucket_size
        buckets[bucket] = buckets.get(bucket, 0) + count
    
    if buckets:
        # Create heatmap data
        max_bucket = max(buckets.keys())
        heatmap_data = []
        
        for i in range(max_bucket + 1):
            count = buckets.get(i, 0)
            start_line = i * bucket_size + 1
            end_line = min((i + 1) * bucket_size, total_lines)
            heatmap_data.append([f"Lines {start_line}-{end_line}", count])
        
        # Create heatmap
        fig = go.Figure(data=go.Heatmap(
            z=[[row[1] for row in heatmap_data]],
            x=[row[0] for row in heatmap_data],
            y=['Vulnerabilities'],
            colorscale='Reds',
            showscale=True,
            hovertemplate='%{x}<br>Vulnerabilities: %{z}<extra></extra>'
        ))
        
        fig.update_layout(
            title="Vulnerability Density Across Contract",
            height=150,
            xaxis_title="Code Sections",
            yaxis_title=""
        )
        
        st.plotly_chart(fig, use_container_width=True)


def show_vulnerability_comparison(ai_vulns: List[Dict], slither_vulns: List[Dict], mythril_vulns: List[Dict]) -> None:
    """
    Display a comparison of vulnerabilities found by different tools.
    
    Args:
        ai_vulns: Vulnerabilities found by AI model
        slither_vulns: Vulnerabilities found by Slither
        mythril_vulns: Vulnerabilities found by Mythril
    """
    st.markdown("### âš–ï¸ Tool Comparison")
    
    # Count vulnerabilities by tool
    tool_counts = {
        'AI Model': len(ai_vulns),
        'Slither': len(slither_vulns),
        'Mythril': len(mythril_vulns)
    }
    
    # Display counts
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("AI Model", tool_counts['AI Model'])
    with col2:
        st.metric("Slither", tool_counts['Slither'])
    with col3:
        st.metric("Mythril", tool_counts['Mythril'])
    
    # Create comparison chart
    fig = go.Figure(data=[
        go.Bar(
            x=list(tool_counts.keys()),
            y=list(tool_counts.values()),
            marker_color=['#4CAF50', '#2196F3', '#FF9800']
        )
    ])
    
    fig.update_layout(
        title="Vulnerabilities Found by Each Tool",
        xaxis_title="Analysis Tool",
        yaxis_title="Number of Vulnerabilities",
        height=300
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Show consensus and unique findings
    if any(tool_counts.values()):
        st.markdown("#### Consensus Analysis")
        
        # Find common vulnerability types
        ai_types = set(v.get('vulnerability_type') for v in ai_vulns)
        slither_types = set(v.get('vulnerability_type') for v in slither_vulns)
        mythril_types = set(v.get('vulnerability_type') for v in mythril_vulns)
        
        consensus = ai_types & slither_types & mythril_types
        
        if consensus:
            st.success(f"ğŸ¤ Consensus findings: {', '.join(consensus)}")
        else:
            st.info("â„¹ï¸ No consensus findings across all tools")
        
        # Show unique findings
        ai_unique = ai_types - slither_types - mythril_types
        slither_unique = slither_types - ai_types - mythril_types
        mythril_unique = mythril_types - ai_types - slither_types
        
        if ai_unique:
            st.warning(f"ğŸ¤– AI Model unique: {', '.join(ai_unique)}")
        if slither_unique:
            st.warning(f"ğŸ” Slither unique: {', '.join(slither_unique)}")
        if mythril_unique:
            st.warning(f"âš¡ Mythril unique: {', '.join(mythril_unique)}")


def create_vulnerability_filter(vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Create filters for vulnerability display.
    
    Args:
        vulnerabilities: List of vulnerability dictionaries
        
    Returns:
        Filtered list of vulnerabilities
    """
    if not vulnerabilities:
        return []
    
    st.markdown("### ğŸ”§ Filter Vulnerabilities")
    
    # Get unique values for filters
    severities = list(set(v.get('severity', 'Unknown') for v in vulnerabilities))
    types = list(set(v.get('vulnerability_type', 'Unknown') for v in vulnerabilities))
    
    col1, col2 = st.columns(2)
    
    with col1:
        selected_severities = st.multiselect(
            "Filter by Severity",
            options=severities,
            default=severities,
            key="severity_filter"
        )
    
    with col2:
        selected_types = st.multiselect(
            "Filter by Type",
            options=types,
            default=types,
            key="type_filter"
        )
    
    # Apply filters
    filtered_vulns = []
    for vuln in vulnerabilities:
        if (vuln.get('severity', 'Unknown') in selected_severities and
            vuln.get('vulnerability_type', 'Unknown') in selected_types):
            filtered_vulns.append(vuln)
    
    return filtered_vulns